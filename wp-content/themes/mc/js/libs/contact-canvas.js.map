{"version":3,"names":[],"mappings":"","sources":["libs/contact-canvas.js"],"sourcesContent":["export class ContactCanvas {\n  constructor(el) {\n    this.DOM = {};\n    this.DOM.el = el;\n    this.canvas = this._initCanvas();\n  }\n\n  _initCanvas() {\n    const contactCanvas = document.querySelector(this.DOM.el);\n\n    const sketch = (p) => {\n      p.setup = () => {\n        p.createCanvas(contactCanvas.clientWidth, contactCanvas.clientHeight);\n        p.reset();\n      };\n\n      p.reset = () => {\n        p.draw();\n      };\n\n      p.draw = () => {\n        p.frameRate(12);\n        p.colorMode(p.HSB);\n        p.background(0, 0, 0);\n        p.bgGradation();\n        p.circleGradation();\n        p.aurora();\n      };\n\n      // 背景グラデーション\n      p.bgGradation = () => {\n        const bgPalette = ['hsl(0, 100%, 10%)', 'hsl(50, 100%, 10%)']; // 背景色\n\n        for (let i = 0; i <= p.height; i += 1) {\n          const bgColor = p.lerpColor(p.color(bgPalette[0]), p.color(bgPalette[1]), i / p.height);\n          p.stroke(bgColor);\n          p.line(0, i, p.width, i);\n        }\n      };\n\n      // 円グラデーション\n      p.circleGradation = () => {\n        if (window.matchMedia('(max-width: 599px)').matches) {\n          const yNumber = 5; // y軸の円の数\n          const xNumber = 5; // x軸の円の数\n\n          console.log(xNumber);\n\n          for (let j = 0; j < yNumber; j += 1) {\n            for (let i = 0; i < xNumber; i += 1) {\n              const translateX = (p.width / (xNumber - 1)) * i; // 円の数から-1を引いて画面端の左右の隙間を埋める\n              const translateY = (p.height / (yNumber - 1)) * j; // 円の数から-1を引いて画面端の左右の隙間を埋める\n\n              const mouseDist = p.dist(translateX, translateY, p.mouseX, p.mouseY); // 円ごとにマウスからの距離を計算\n              const circleDiameter = p.map(mouseDist, 0, p.dist(0, 0, p.width, p.height), 0, 100); // 距離の範囲を円のサイズの範囲に変換\n\n              const hsbDist = p.dist(translateX, translateY, p.width / 2, p.height / 2); // 円ごとに画面中央からの距離を計算\n              const hsb = p.map(hsbDist, 0, p.dist(0, 0, p.width / 2, p.height / 2), 230, 300); // 端から中央までグラデーション\n\n              p.fill(hsb, 100, 75);\n              p.circle(translateX, translateY, circleDiameter);\n            }\n          }\n        } else if (window.matchMedia('(min-width:600px)').matches) {\n          const yNumber = 6; // y軸の円の数\n          const xNumber = 12; // x軸の円の数\n\n          for (let j = 0; j < yNumber; j += 1) {\n            for (let i = 0; i < xNumber; i += 1) {\n              const translateX = (p.width / (xNumber - 1)) * i; // 円の数から-1を引いて画面端の左右の隙間を埋める\n              const translateY = (p.height / (yNumber - 1)) * j; // 円の数から-1を引いて画面端の左右の隙間を埋める\n\n              const mouseDist = p.dist(translateX, translateY, p.mouseX, p.mouseY); // 円ごとにマウスからの距離を計算\n              const circleDiameter = p.map(mouseDist, 0, p.dist(0, 0, p.width, p.height), 0, 180); // 距離の範囲を円のサイズの範囲に変換\n\n              const hsbDist = p.dist(translateX, translateY, p.width / 2, p.height / 2); // 円ごとに画面中央からの距離を計算\n              const hsb = p.map(hsbDist, 0, p.dist(0, 0, p.width / 2, p.height / 2), 230, 320); // 端から中央までグラデーション\n\n              p.fill(hsb, 100, 75);\n              p.circle(translateX, translateY, circleDiameter);\n            }\n          }\n        }\n      };\n\n      // オーロラ\n      p.aurora = () => {\n        const lineNum = 10; // ラインの数\n        const segmentNum = 20; // 分割数\n\n        let radian = 0; // ラジアン（角度）\n        const centerHue = 235; // 基準色\n        const hueRange = 60; // 色の幅\n        const satuRange = 25; // 彩度の幅\n        const lumiRange = 25; // 明度の幅\n        const speed = 0.2; // 時間経過\n\n        for (let j = 0; j < lineNum; j += 1) {\n          const time = Date.now() / 2500; // 媒介変数(時間)\n          const coefficient = 30 + j; // 係数\n\n          const h = centerHue + Math.round(Math.cos(radian) * hueRange); // 色相（hue）⁠\n          const s = 75 + Math.round(Math.cos(radian) * satuRange); // 彩度（saturation）\n          const l = 100 - Math.round(Math.cos(radian) * lumiRange); // 明度（luminance）\n\n          radian += speed; // 時間経過でラジアンを増やす\n\n          p.beginShape(p.QUADS);\n          p.stroke(h, s, l);\n\n          for (let i = 0; i < segmentNum; i += 1) {\n            const x = (i / (segmentNum - 1)) * p.width; // X座標\n            const px = i / coefficient; // 横軸の入力値（水平方向の距離）\n            const py = (j / 30 + time); // 時間の入力値\n            // console.log(px, py);\n            const randomValue = p.noise(px, py); // 乱数\n            // console.log(randomValue);\n            const y = randomValue * p.height; // Y座標（乱数 * 高さ）\n\n            p.vertex(x, y);\n          }\n\n          p.endShape();\n        }\n      };\n\n      // 画面更新時にリサイズ\n      p.windowResized = () => {\n        p.resizeCanvas(contactCanvas.clientWidth, contactCanvas.clientHeight);\n        p.reset();\n      };\n\n      // 要素に入ったらループ開始\n      p.start = () => {\n        p.loop();\n      };\n\n      // 要素から出たらループ停止\n      p.stop = () => {\n        p.noLoop();\n      };\n    };\n\n    return new p5(sketch, contactCanvas);\n  }\n\n  start() {\n    this.canvas.start();\n  }\n\n  stop() {\n    this.canvas.stop();\n  }\n}\n"],"file":"contact-canvas.js"}