{"version":3,"names":[],"mappings":"","sources":["libs/menu-open.js"],"sourcesContent":["export class MenuOpen {\n  constructor() {\n    this.DOM = {};\n    this.DOM.html = document.documentElement; // ルート要素<html>を返す\n    this.DOM.header = document.querySelector('.header');\n    this.DOM.btn = document.querySelector('.header__btn');\n    this.DOM.canvas = document.querySelector('.gnav__canvas');\n    this.eventType = this._getEventType();\n    this._addEvent();\n    this.canvas = this._initCanvas();\n    this._canvasStop();\n  }\n\n  _getEventType() {\n    const isTouchCapable = 'ontouchstart' in window\n      || (window.DocumentTouch && document instanceof window.DocumentTouch)\n      || navigator.maxTouchPoints > 0\n      || window.navigator.msMaxTouchPoints > 0;\n\n    return isTouchCapable ? 'touchstart' : 'click';\n  }\n\n  _toggle() {\n    this.DOM.header.classList.toggle('menu-open');\n    if (this.DOM.header.classList.contains('menu-open')) {\n      this.DOM.html.classList.add('fixed');\n      this._canvasStart();\n    } else {\n      this.DOM.html.classList.remove('fixed');\n      this._canvasStop();\n    }\n  }\n\n  _initCanvas() {\n    const gnavCanvas = this.DOM.canvas;\n    let particles;\n\n    const sketch = (p) => {\n      p.setup = () => {\n        p.createCanvas(gnavCanvas.clientWidth, gnavCanvas.clientHeight);\n        p.noStroke();\n        particles = [];\n        p.textAlign(p.CENTER);\n        p.reset();\n      };\n\n      p.reset = () => {\n        p.draw();\n      };\n\n      p.draw = () => {\n        p.clear();\n        p.frameRate(24);\n        p.background(0, 0, 0, 0.5);\n        genRadialGradient();\n        genParticle();\n      };\n\n      // 円形グラデーションを生成\n      function genRadialGradient() {\n        // 影をつける\n        p.drawingContext.shadowOffsetX = 5;\n        p.drawingContext.shadowOffsetY = 5;\n        p.drawingContext.shadowColor = p.color(242, 70, 69);\n        p.drawingContext.shadowBlur = 10;\n\n        // 円形グラデーションを指定（開始円：x0, y0, r0、終了円：x1, y1, r1）\n        const gradientFill = p.drawingContext.createRadialGradient(\n          p.width / 2,\n          p.height / 2,\n          p.constrain(p.mouseY * 0.1, 0, p.width * 0.1), // 開始円をマウスで操作し、終了円より大きくなるを防ぐ\n          p.width / 2,\n          p.height / 2,\n          p.width * 0.35,\n        );\n\n        // グラデーションの開始位置（offset）、追加するカラー\n        gradientFill.addColorStop(0, p.color(255, 0, 0));\n        gradientFill.addColorStop(0.5, p.color(255, 255, 0));\n        gradientFill.addColorStop(1, p.color(255, 0, 0, 0.5));\n\n        // グラデーションを指定\n        p.drawingContext.fillStyle = gradientFill;\n\n        // 中心の円形グラデーションを作成\n        p.circle(p.width / 2, p.height / 2, p.width * 1.0);\n      }\n\n      // パーティクルを生成\n      function genParticle() {\n        const interval = 10;\n        const maxParticle = 20;\n        const generateParticle = {\n          // 位置、速度、半径\n          init(x, y, velocityX, velocityY, radius, lifespan, damage) {\n            return {\n              x, y, velocityX, velocityY, radius, lifespan, damage,\n            };\n          },\n\n          update(ptl) {\n            ptl.x += ptl.velocityX; // ランダムな速度を位置に代入\n            ptl.y += ptl.velocityY; // ランダムな速度を位置に代入\n            ptl.lifespan -= ptl.damage; // 毎フレームlifespanからdamageを引く\n            ptl.lifespan = p.max(ptl.lifespan); // lifespanが0以下になったら配列から削除\n          },\n\n          draw(ptl) {\n            p.fill(80, 0, 90, ptl.lifespan); //  lifespanの値を透明度に設定\n            p.circle(ptl.x, ptl.y, ptl.radius * 2);\n          },\n        };\n\n        // パーティクルを配列に追加\n        function addParticle() {\n          const velocityX = p.random(-3, 3);\n          const velocityY = p.random(-3, 3);\n          const radius = p.random(15, 35);\n          const lifespan = 250;\n          const damage = p.random(1, 3);\n          const particle = generateParticle.init(p.mouseX, p.mouseY, velocityX, velocityY, radius, lifespan, damage);\n          particles.push(particle);\n        }\n\n        // パーティクルの数を確認\n        // p.fill(255);\n        // p.text(`${particles.length} / ${maxParticle}`, p.width / 2, p.height / 2);\n\n        // frameCountがintervalの倍数時にmaxParticleまでパーティクルを追加\n        if (p.frameCount % interval === 0 && particles.length < maxParticle) {\n          addParticle();\n        }\n\n        // パーティクルの配列の長さまで、変数iから個々のパーティクルを変数ptlとして取り出す\n        for (let i = 0; i < particles.length; i += 1) {\n          const ptl = particles[i];\n          generateParticle.update(ptl); // 引数にptlを渡して個々のパーティクルの速度とライフスパンを更新\n          generateParticle.draw(ptl); // 更新したptlを実行\n        }\n\n        // filterでlifespanが0より大きい場合はparticlesにptlを追加（ループを維持させる）\n        particles = particles.filter((ptl) => ptl.lifespan > 0);\n      }\n\n      // 画面更新時にリサイズ\n      p.windowResized = () => {\n        p.resizeCanvas(gnavCanvas.clientWidth, gnavCanvas.clientHeight);\n        p.reset();\n      };\n\n      // ボタンをクリックしたらループ開始\n      p.start = () => {\n        p.loop();\n      };\n\n      // 初期時とボタンを再クリックしたらループ停止\n      p.stop = () => {\n        p.noLoop();\n      };\n    };\n\n    return new p5(sketch, gnavCanvas);\n  }\n\n  _canvasStart() {\n    this.canvas.start();\n    console.log('gnav start is called');\n  }\n\n  _canvasStop() {\n    this.canvas.stop();\n    console.log('gnav stop is called');\n  }\n\n  _addEvent() {\n    this.DOM.btn.addEventListener(this.eventType, this._toggle.bind(this), { passive: true });\n  }\n}\n"],"file":"menu-open.js"}